\chapter{Introduction}

\section{Motivation \& Problem Statement}

\emph{Parsing} is the process of taking input and converting it into a data structure~\cite{wikipedia2016Parser, grune2007parsing}. Research around this topic focuses on how to process the input and the general computational complexity of algorithms to handle certain kind of \emph{formal languages}.

\begin{figure}[H]
  \centering
    \includegraphics[width=.8\textwidth]{Parsing}
  \caption{Simplified view of the parsing process}
\end{figure}

This thesis concerns itself with the parsing process of languages that are able to express configuration data (e.g. INI, TOML, YAML). These languages form an interesting subpart of formal languages, since most computer programs only store and access key-value based persistent configuration data.

Just like people disagree about the “best” configuration format, there is currently no consensus, as to which is the ideal way to parse configuration data. There are many possible ways to parse and store data. Notable examples include:

\begin{itemize}
  \item Bidirectional programming~\cite{foster2005combinators, bohannon2006relational, lutterkort2008augeas, ko2016bigul, raab2016improving}
  \item Code produced by a parser generator~\cite{denny2008ielr, parr2014adaptive, warth2016modular, bates2017aprt}
  \item Serialization libraries~\cite{sumaray2012cds, pacini2015performance}
  \item Hand-written parsers~\cite{myers2008cparser, bendersky2012clang}
\end{itemize}

. Currently the possibilities to compare different parsing techniques are limited. The naive approach would be to just run different parsers on the same data. In practice however, this approach is not usable, since parser tools tend to produce very different data structures. Some of them do not produce data structures at all, instead they let the user specify subroutines that should be called when the parser matches parts of the grammar.

As part of this thesis we will tackle this problem, using different parsing techniques within a common configuration framework. This integration eliminates the problem of comparing the parsing process under different circumstances, since the data structures the parsers create will always be the same. We will use \href{http://web.libelektra.org}{Elektra}, a key-value database, as configuration framework. Elektra’s storage plugin interface will act as foundation for the parsing process. In the end the thesis should provide answers about which parsing techniques provide an ideal balance between performance and usability.

\section{Aim of the Work}
\label{sec:aim_of_the_work}

Elektra~\cite{raab2010modular, raab2017context} is a plugin based framework that stores configuration parameters in a \glsdesc{KDB}. Elektra reads and stores configuration data via so-called \emph{storage plugins}.

\begin{figure}[H]
  \centering
    \includegraphics[width=.3\textwidth]{Elektra.pdf}
  \caption{Architecture diagram of Elektra}
\end{figure}

As part of this thesis we compare various ways of parsing. For that purpose we wrote and generated parsing code for different storage plugins. All of these storage plugins parse a minimal subset of \glstext{YAML}, a human readable configuration language. We looked at the following parsing technologies:

\begin{itemize}
  \item Handwritten Parser (Recursive Descent)
  \item ALL(*)-Parser Generator (\href{http://www.antlr.org}{ANTLR})
  \item LR-Parser Generator (\href{https://www.gnu.org/software/bison}{GNU Bison})
  \item Earley Parser (\href{https://github.com/vnmakarov/yaep}{yaep})
  \item PEG-Parser (\href{https://github.com/ColinH/PEGTL}{PEGTL})
  \item Parser Combinator (\href{https://github.com/orangeduck/mpc}{mpc})
  \item Bidirectional Programming (\href{http://augeas.net}{Augeas})
\end{itemize}

. We compare the parsing code according to the following criteria:

\begin{itemize}
  \item Runtime Performance
  \item Memory Usage
  \item Code Size
  \item Overall Code Complexity
  \item Ease of Extensibility and Composability
  \item Error Reporting
\end{itemize}

. After we finished the parsing code for the minimal (but challenging) YAML subset, we wrote a more complete \glstext{YAML} parser using the most promising technique.

In the scope of the above comparison we answer the questions below.

% Research question should be:
%
% - clear,
% - focused (fixed scope), and
% - complex (not answerable with yes no)
%
% .
\begin{restatable}{question}{closeness}
  \label{que:closeness}
  Which parsing technique allows us to stay closest to the definition of the configuration language? Does staying close to the given definition,
  allow us to extend and improve the parser and its support code more easily?
\end{restatable}

\begin{restatable}{question}{speed}
  \label{que:speed}
  How does the theoretic runtime complexity of the parsing methods compare to the actual measured runtime of the parsing code? How large is the potential runtime overhead introduced by the intermediate representations of the used parsing libraries/generators?
\end{restatable}

\section{Methodological Approach}

The methodological approach for this thesis consists of the following steps:

\begin{description}[style=multiline, leftmargin=3.2cm, font=\bfseries]

  \item[Literature Review] We determined the current status of parsing libraries suitable for configuration file parsing. We then chose appropriate libraries for the parsing techniques listed in the section “\nameref{sec:aim_of_the_work}”.

  \item[Discussion] To determine a minimal usable subset of YAML we discussed common features required for a new Elektra storage plugin with some of the current developers as part of an presentation and subsequent discussion.

  \item[Implementation] First we implemented parsing code for the minimal YAML subset. In this phase we also added other necessary code to Elektra. After that we chose one of the parsing methods to create a more complete \glstext{YAML} parser.

  \item[Comparison] As noted in “\nameref{sec:aim_of_the_work}” we evaluated the different implementations of our minimal YAML subset parsers.

  \begin{description}
    \item[Benchmark] For the speed comparison we use benchmarks to determine the speed of the different YAML plugins. In this part of the thesis, we will also answer \Cref{que:speed}.
  \end{description}

\end{description}
