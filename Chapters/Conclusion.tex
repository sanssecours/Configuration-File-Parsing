\chapter{Conclusion \& Future Work}

% References
% ==========
%
% - https://patthomson.net/2018/01/29/concluding-the-thesis-four-key-actions
%
% Guidelines
% ==========
%
% - To what extent you achieved your aims/objectives OR not: if not, why not?
% - How important and significant your results are, as well as any limitations
%   of your research (e.g. small sample size; other variables)
% - Where the research should go from here: what are some interesting further
%   areas to be explored based on what you have discovered or proven?
%
% - restates the question
% - provides a succinct summary of the answer(s) and how this was produced ( I
%   did this and my analysis showed 1, 2, 3 and I argue that this… ). The writer
%   usually acknowledges the particularity of the research here too (sometimes
%   called limitations.)
% - shows how the research contributes to the literatures (the contribution of
%   the research is a, b, c)
% - discusses the implications (the results could lead to further research on,
%   changes in policy/practice such as.. ). The implications arise logically from
%   the particularity of the study and its results – they point to questions the
%   study opens up, what the results says to current thinking about and acting on
%   the topic.
%
% Contribution
% ============
%
% - Real world comparison of common file parsing techniques
% - Common data structure (better comparison possibilities)
%
% Limitations
% ===========
%
% - Only looked at YAML: Other configuration file formats would be interesting too
% - Additional parsing libraries in other programming languages might be better
%   for parsing config data
% - Did not use Augeas (not powerful enough) and mpc (less powerful version of
%   PEGTL)
% - More test data for performance test (parser more complete set of YAML)
%
% Future Work
% ===========
%
% - Add lexer level error messages
% - Add escaping and unescaping support for single and double quoted scalars

\section{Conclusion}

In the thesis we compared different parsing techniques using the \nameref{sec:keyset} structure of the configuration framework \href{https://www.libelektra.org}{Elektra} as common end product of the parsing process. The aim of this task was to find the most promising parsing technique for configuration files using a subset of the language \glstext{YAML} as example.

In a \hyperref[sec:comparison]{detailed comparison} we determined the answer to our research questions.

\speed*

The \hyperref[sec:run_time_performance]{benchmarks} showed a significant difference between the runtime of the \hyperref[sec:implementation]{parsing plugins} created in the scope of the thesis, especially for large files. However, at least for our example data, all the plugins \hyperref[fig:benchmark_results_generated_above_1000]{showed linear runtime behavior}. Even the PEG parser library \gls{PEGTL} that has a theoretical exponential runtime in the worst case showed this linear behavior. Interestingly, \gls{YAEP}, the library that uses one of the most powerful parsing techniques tested (Earley parsing), showed the \hyperref[fig:benchmark_generated]{best runtime performance on macOS}. Even on Linux the library was only \hyperref[fig:benchmark_generated]{slightly slower than the fastest parser, based on Bisons’ LALR code}.

\closeness*

We showed that the \gls{PEG} library \gls{PEGTL} allowed us to stay much closer to the representation of the \href{http://yaml.org/spec/1.2/spec.html}{specification of our example language YAML}. This closeness provides utility, when we compare the ease of extensibility of the language grammar. However, since in the case of YAML, the language specification is rather low level, the extension of the support code that converts the data in Elektra’s data structures takes more effort, than for the lexer based parsers.

In the end, \gls{ANTLR}, the parsing engine

\begin{itemize}
  \item that provided the most complete support code, and
  \item that produces good error messages, without any changes to the grammar
\end{itemize}

showed the best overall results according to our \hyperref[sec:comparison]{comparison}. Bison and \gls{YAEP} also showed promising results, while yaml-cpp and PEGTL did not fit all \hyperref[sec:requirements_extended_yaml_plugin]{requirements for an extended YAML storage plugin well}. In the beginning of the thesis we also considered using the bidirectional programming library Augeas and the parser combinator library mpc. However, in the implementation phase we found that both of these libraries are unsatisfactory for our needs. Augeas is not able to process the context sensitive language YAML, and mpc does not seem to offer any significant advantage over the similar library \gls{PEGTL}.

Overall this thesis provides a thorough comparison of current implementations of parsing techniques in the context of configuration data. There are certainly other papers that compare libraries or parsing engines using either a specialized format such as JSON~\cite{json2019geoff} or multiple grammars~\cite{chen2011full, flodin2014packrat}. However, the comparability of the parsers in these papers is usually limited by the fact that they do not use the same common data structure.

\section{Future Work}

While we think that the comparison presented in this theses is thorough, we found some limitations future research could take into consideration.

\subsection{Additional Data Formats}

The \glstext{YAML} file format we used as example is quite complicated. We therefore used a custom lexer instead of a standard tool, like ANTLR’s lexer or flex, to make the parsing process of the whitespace rules of the language easier. It would make sense to also write, generate, and compare parsing code for simpler data configuration formats, such as JSON, TOML or INI. These formats should make it easier to use a standard lexing tool, and allow us to determine how much influence a lexing tool has on the overall parsing process.

\subsection{Typing Support}

We did not consider proper type support in the thesis. While we added support for binary data to the \LinkYAMLCPP{} plugin, most of the other code we wrote does not support types properly. This can lead to problems, such as \href{https://issues.libelektra.org/2833}{unwanted conversions from boolean data to integer values}.

\subsection{Lexer Level Error Messages}

The custom lexer code written in this thesis does not detect or report errors at the token level. Adding support for this feature should be relatively easy and allow us to compare error messages for common low level mistakes. This is especially interesting, since we would be able to assess, if the PEG library \gls{PEGTL} is able to provide the same error message quality as handwritten custom code for low level errors.

\subsection{Additional Parser Engines/Generators}

To improve the comparability of the runtime and memory benchmarks we only considered tools written in C or C++ in this thesis. However, some of the most interesting parsing research focuses on tools written in other programming languages.

\begin{description}[style=multiline, leftmargin=3cm, font=\bfseries]
  \item [Menhir (OCaml)] Menhir is a LR parser generator that provides support for “example based error reporting”~\cite{jeffery2003generating, kaestner2018compcert, pottier2019menhir}. In theory we should be able to generate parsers with Menhir that produce error messages comparable to the ones of handwritten recursive descent parsers, used in tools such as Clang or GCC~\cite[p. 2]{kaestner2018compcert}.

  \item[LPegLabel (Lua)] This library supports some of the recent interesting features for error handling in \glspl{PEG}, such as labeled failures~\cite{maidl2016labeled} and syntax error recovery~\cite{medeiros2018recovery}.

  \item[Marpa (Perl)] Marpa is a parsing library based on Earley’s parsing algorithm. The library implements improvements to the algorithm from \citeauthor{leo1991general}~\cite{leo1991general} and \citeauthor{aycock2002practical}~\cite{aycock2002practical}. According to the author~\cite{kegler2019marpa}:

  \begin{quote}
    Marpa is intended to replace, and to go well beyond, recursive descent and the yacc family of parsers.
  \end{quote}

  .
\end{description}
